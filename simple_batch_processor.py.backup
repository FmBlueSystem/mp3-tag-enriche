#!/usr/bin/env python3
"""
ğŸµ PROCESADOR SIMPLE Y SEGURO DE MP3
===================================

Procesador que evita el congelamiento con:
- MÃ¡ximo 1 archivo a la vez (sin concurrencia)
- Rate limiting estricto 
- GestiÃ³n de memoria activa
- Progreso visible
- Timeouts configurables
"""

import os
import sys
import gc
import time
import signal
import logging
from pathlib import Path
from typing import Dict, List
from contextlib import contextmanager

# Configurar logging simple
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(message)s',
    handlers=[
        logging.FileHandler('simple_processing.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Agregar directorio del proyecto
project_dir = os.path.dirname(os.path.abspath(__file__))
if project_dir not in sys.path:
    sys.path.append(project_dir)

class SimpleTimeout:
    """Clase simple para manejar timeouts."""
    
    def __init__(self, seconds=30):
        self.seconds = seconds
    
    def __enter__(self):
        signal.signal(signal.SIGALRM, self._timeout_handler)
        signal.alarm(self.seconds)
        return self
    
    def __exit__(self, type, value, traceback):
        signal.alarm(0)
    
    def _timeout_handler(self, signum, frame):
        raise TimeoutError(f"OperaciÃ³n tardÃ³ mÃ¡s de {self.seconds} segundos")

class SimpleMP3Processor:
    """Procesador MP3 simple y seguro."""
    
    def __init__(self):
        self.processed = 0
        self.errors = 0
        self.start_time = time.time()
        
        # ConfiguraciÃ³n conservadora
        self.rate_limit = 2.0  # 2 segundos entre archivos
        self.timeout = 30      # 30 segundos por archivo
        self.memory_cleanup_interval = 3  # Cada 3 archivos
        
        # Crear handler bÃ¡sico
        # API_IMPROVEMENTS_INTEGRATED
# Importar cliente API mejorado si estÃ¡ disponible
try:
    from improved_api_client import ImprovedAPIManager
    API_IMPROVEMENTS_AVAILABLE = True
except ImportError:
    API_IMPROVEMENTS_AVAILABLE = False

from src.core.file_handler import Mp3FileHandler
        backup_dir = os.path.join(project_dir, "mp3_backups")
        os.makedirs(backup_dir, exist_ok=True)
        self.handler = Mp3FileHandler(backup_dir=backup_dir, verbose=False)
    
    @contextmanager
    def safe_processing(self, file_path: str):
        """Context manager para procesamiento seguro."""
        logger.info(f"ğŸ”„ Procesando: {os.path.basename(file_path)}")
        start_time = time.time()
        
        try:
            # Rate limiting
            time.sleep(self.rate_limit)
            
            # Verificar archivo
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"Archivo no encontrado: {file_path}")
            
            if not file_path.lower().endswith('.mp3'):
                raise ValueError(f"No es archivo MP3: {file_path}")
            
            yield
            
        except Exception as e:
            logger.error(f"âŒ Error en {os.path.basename(file_path)}: {e}")
            self.errors += 1
            raise
        
        finally:
            # Cleanup
            gc.collect()
            process_time = time.time() - start_time
            logger.info(f"â±ï¸ Completado en {process_time:.1f}s")
            self.processed += 1
            
            # Mostrar progreso cada archivo
            self._show_progress()
    
    def process_single_file(self, file_path: str, dry_run: bool = True) -> Dict:
        """Procesa un archivo individual con mÃ¡xima seguridad."""
        result = {
            'file': file_path,
            'filename': os.path.basename(file_path),
            'success': False,
            'error': None,
            'info': {}
        }
        
        try:
            with self.safe_processing(file_path):
                with SimpleTimeout(self.timeout):
                    # Usar handler bÃ¡sico (mÃ¡s estable)
                    info = self.handler.get_file_info(file_path)
                    
                    if info:
                        result['info'] = {
                            'artist': info.get('artist', ''),
                            'title': info.get('title', ''),
                            'album': info.get('album', ''),
                            'duration': info.get('duration', ''),
                            'has_metadata': bool(info.get('artist') or info.get('title'))
                        }
                        
                        if not dry_run:
                            # AquÃ­ podrÃ­as aplicar cambios si es necesario
                            logger.info(f"ğŸ“ (Cambios se aplicarÃ­an aquÃ­)")
                        
                        result['success'] = True
                        logger.info(f"âœ… Exitoso: {result['info']['artist']} - {result['info']['title']}")
                    else:
                        result['error'] = 'No se pudo extraer informaciÃ³n'
                        logger.warning(f"âš ï¸ Sin informaciÃ³n: {os.path.basename(file_path)}")
        
        except TimeoutError as e:
            result['error'] = f'Timeout: {str(e)}'
            logger.error(f"â° Timeout en: {os.path.basename(file_path)}")
        
        except Exception as e:
            result['error'] = str(e)
            logger.error(f"ğŸ’¥ Error procesando: {os.path.basename(file_path)} - {e}")
        
        return result
    
    def process_directory(self, directory: str, dry_run: bool = True, max_files: int = None) -> List[Dict]:
        """Procesa directorio de forma secuencial y segura."""
        
        logger.info(f"ğŸµ PROCESADOR SIMPLE MP3 - MODO SEGURO")
        logger.info(f"ğŸ“ Directorio: {directory}")
        logger.info(f"ğŸ“‹ Modo: {'SIMULACIÃ“N' if dry_run else 'APLICAR CAMBIOS'}")
        
        if not os.path.isdir(directory):
            logger.error(f"âŒ Directorio no vÃ¡lido: {directory}")
            return []
        
        # Buscar archivos MP3
        logger.info("ğŸ” Buscando archivos MP3...")
        mp3_files = []
        
        for root, _, files in os.walk(directory):
            for file in files:
                if file.lower().endswith('.mp3'):
                    mp3_files.append(os.path.join(root, file))
                    if max_files and len(mp3_files) >= max_files:
                        break
            if max_files and len(mp3_files) >= max_files:
                break
        
        if not mp3_files:
            logger.error(f"âŒ No se encontraron archivos MP3 en: {directory}")
            return []
        
        total = len(mp3_files)
        logger.info(f"ğŸµ Encontrados {total} archivos MP3")
        logger.info(f"âš™ï¸ Rate limit: {self.rate_limit}s por archivo")
        logger.info(f"â±ï¸ Timeout: {self.timeout}s por archivo")
        logger.info(f"â³ Tiempo estimado: {(total * self.rate_limit) / 60:.1f} minutos")
        logger.info(f"ğŸ”„ Iniciando procesamiento...")
        
        # Procesar secuencialmente (SIN CONCURRENCIA)
        results = []
        
        for i, file_path in enumerate(mp3_files, 1):
            logger.info(f"\nğŸ“Š Archivo {i}/{total} ({i/total*100:.1f}%)")
            
            try:
                result = self.process_single_file(file_path, dry_run)
                results.append(result)
                
                # Cleanup de memoria cada ciertos archivos
                if i % self.memory_cleanup_interval == 0:
                    logger.info("ğŸ§¹ Limpiando memoria...")
                    gc.collect()
                    time.sleep(0.5)
                
            except KeyboardInterrupt:
                logger.info(f"\nğŸ›‘ Interrumpido por usuario en archivo {i}")
                break
            
            except Exception as e:
                logger.error(f"ğŸ’¥ Error crÃ­tico en archivo {i}: {e}")
                results.append({
                    'file': file_path,
                    'filename': os.path.basename(file_path),
                    'success': False,
                    'error': f'Error crÃ­tico: {str(e)}'
                })
                # Continuar con el siguiente archivo
                continue
        
        # Resumen final
        self._show_final_summary(results, total)
        
        return results
    
    def _show_progress(self):
        """Muestra progreso actual."""
        elapsed = time.time() - self.start_time
        if self.processed > 0:
            avg_time = elapsed / self.processed
            logger.info(f"ğŸ“ˆ Progreso: {self.processed} procesados, {self.errors} errores, {avg_time:.1f}s/archivo promedio")
    
    def _show_final_summary(self, results: List[Dict], total: int):
        """Muestra resumen final."""
        elapsed = time.time() - self.start_time
        success_count = sum(1 for r in results if r.get('success', False))
        
        logger.info(f"\nğŸ RESUMEN FINAL")
        logger.info(f"=" * 40)
        logger.info(f"ğŸ“ Total archivos: {total}")
        logger.info(f"ğŸ”„ Procesados: {len(results)}")
        logger.info(f"âœ… Exitosos: {success_count} ({success_count/len(results)*100:.1f}%)")
        logger.info(f"âŒ Errores: {self.errors} ({self.errors/len(results)*100:.1f}%)")
        logger.info(f"â±ï¸ Tiempo total: {elapsed/60:.1f} minutos")
        logger.info(f"âš¡ Promedio: {elapsed/len(results):.1f}s por archivo")
        
        # Mostrar algunos exitosos
        success_files = [r for r in results if r.get('success') and r.get('info', {}).get('has_metadata')]
        if success_files:
            logger.info(f"\nğŸµ ARCHIVOS CON METADATA (primeros 5):")
            for result in success_files[:5]:
                info = result['info']
                logger.info(f"   ğŸ¤ {info['artist']} - {info['title']}")
        
        # Mostrar algunos errores
        error_files = [r for r in results if r.get('error')]
        if error_files:
            logger.info(f"\nâŒ ERRORES (primeros 3):")
            for result in error_files[:3]:
                logger.info(f"   ğŸ’¥ {result['filename']}: {result['error']}")

def main():
    """FunciÃ³n principal."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="ğŸµ Procesador MP3 simple y seguro (no se congela)"
    )
    parser.add_argument('--directory', '-d', required=True,
                       help='Directorio con archivos MP3')
    parser.add_argument('--apply', '-a', action='store_true',
                       help='Aplicar cambios (por defecto solo analiza)')
    parser.add_argument('--max-files', type=int,
                       help='NÃºmero mÃ¡ximo de archivos a procesar')
    
    args = parser.parse_args()
    
    # Crear procesador
    processor = SimpleMP3Processor()
    
    # Procesar
    try:
        results = processor.process_directory(
            directory=args.directory,
            dry_run=not args.apply,
            max_files=args.max_files
        )
        
        logger.info(f"\nğŸ‰ Procesamiento completado sin congelamiento!")
        logger.info(f"ğŸ“ Ver detalles en: simple_processing.log")
        
    except KeyboardInterrupt:
        logger.info(f"\nğŸ‘‹ Detenido por usuario")
    except Exception as e:
        logger.error(f"ğŸ’¥ Error fatal: {e}")

if __name__ == "__main__":
    main() 