#!/usr/bin/env python3
"""
üéµ DETECTOR DE G√âNEROS MUSICALES - LAUNCHER UNIFICADO
====================================================

Punto de entrada √∫nico para todas las funcionalidades del sistema.
Auto-detecta el mejor modo de ejecuci√≥n basado en el entorno.

Uso:
    python main.py                      # Auto-detect: GUI si disponible, CLI si no
    python main.py --gui                # Forzar modo GUI
    python main.py --cli [archivos]     # Forzar modo CLI
    python main.py --batch <directorio> # Modo procesamiento batch
    python main.py --analyze <archivos> # Solo an√°lisis sin modificar
    python main.py --help               # Ayuda completa

Ejemplos:
    python main.py                                    # Modo autom√°tico
    python main.py --cli /ruta/a/archivo.mp3         # CLI directo
    python main.py --batch /ruta/a/directorio/       # Procesamiento masivo
    python main.py --analyze /ruta/*.mp3             # Solo an√°lisis
"""

import sys
import os
import argparse
import logging
from typing import List, Optional
from pathlib import Path

# Configurar logging b√°sico
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class UnifiedLauncher:
    """Launcher unificado para todas las interfaces del sistema."""
    
    def __init__(self):
        self.gui_available = self._check_gui_availability()
        self.project_root = Path(__file__).parent
        
    def _check_gui_availability(self) -> bool:
        """Verifica si la GUI est√° disponible."""
        try:
            # Verificar dependencias GUI
            import PySide6
            from src.gui.main_window import MainWindow
            
            # Verificar entorno gr√°fico
            if sys.platform == 'darwin':  # macOS
                return True
            elif sys.platform.startswith('linux'):
                return bool(os.environ.get('DISPLAY'))
            elif sys.platform == 'win32':  # Windows
                return True
            
            return False
        except ImportError as e:
            logger.debug(f"GUI no disponible: {e}")
            return False
    
    def auto_detect_mode(self) -> str:
        """Auto-detecta el mejor modo basado en entorno y argumentos."""
        # Si hay argumentos espec√≠ficos de CLI, usar CLI
        if len(sys.argv) > 1:
            if any(arg in sys.argv for arg in ['--cli', '--batch', '--analyze']):
                return 'cli'
        
        # Si GUI est√° disponible y no hay argumentos espec√≠ficos de CLI
        if self.gui_available:
            return 'gui'
        
        return 'cli'
    
    def run_gui(self):
        """Ejecutar interfaz gr√°fica."""
        try:
            logger.info("üñ•Ô∏è  Iniciando interfaz gr√°fica...")
            from PySide6.QtWidgets import QApplication
            from src.gui.main_window import MainWindow
            from src.gui.style import apply_dark_theme
            
            app = QApplication(sys.argv)
            apply_dark_theme(app)
            window = MainWindow()
            window.show()
            
            logger.info("‚úÖ GUI iniciada correctamente")
            sys.exit(app.exec())
            
        except ImportError as e:
            logger.error(f"‚ùå Error importando GUI: {e}")
            print("‚ùå GUI no disponible. Cambiando a modo CLI...")
            self.run_cli()
        except Exception as e:
            logger.error(f"‚ùå Error ejecutando GUI: {e}")
            print(f"‚ùå Error en GUI: {e}")
            print("üîÑ Cambiando a modo CLI...")
            self.run_cli()
    
    def run_cli(self, paths: Optional[List[str]] = None, 
                analyze_only: bool = False, 
                batch_mode: bool = False,
                **kwargs):
        """Ejecutar interfaz de l√≠nea de comandos."""
        try:
            logger.info("üíª Iniciando interfaz CLI...")
            
            if batch_mode and paths:
                self._run_batch_mode(paths[0], **kwargs)
            else:
                self._run_standard_cli(paths, analyze_only, **kwargs)
                
        except Exception as e:
            logger.error(f"‚ùå Error ejecutando CLI: {e}")
            print(f"‚ùå Error en CLI: {e}")
            sys.exit(1)
    
    def _run_standard_cli(self, paths: Optional[List[str]], analyze_only: bool, **kwargs):
        """Ejecutar CLI est√°ndar usando el sistema moderno."""
        try:
            # Usar el CLI moderno de src/__main__.py
            from src.__main__ import main as cli_main
            from src.__main__ import create_detector, process_files
            
            if not paths:
                # Si no hay paths, usar directorio por defecto o pedir al usuario
                default_dir = "/Volumes/My Passport/Dj compilation 2025/DMS/DMS 80s"
                if os.path.exists(default_dir):
                    paths = [default_dir]
                else:
                    print("üìÅ No se especificaron archivos. Usando directorio actual...")
                    paths = ["."]
            
            # Crear detector con configuraci√≥n unificada
            detector = create_detector(
                backup_dir=kwargs.get('backup_dir', "/Volumes/My Passport/Dj compilation 2025/Respados mp3"),
                use_spotify=not kwargs.get('no_spotify', False),
                verbose=kwargs.get('verbose', True)
            )
            
            # Procesar archivos
            results = process_files(
                detector=detector,
                paths=paths,
                recursive=kwargs.get('recursive', True),
                analyze_only=analyze_only,
                confidence=kwargs.get('confidence', 0.3),
                max_genres=kwargs.get('max_genres', 3)
            )
            
            # Mostrar resumen
            total_processed = len([r for r in results.values() if r])
            print(f"\n‚úÖ Procesamiento completado: {total_processed} archivos")
            
        except ImportError:
            # Fallback al CLI legacy si el moderno no est√° disponible
            logger.warning("CLI moderno no disponible, usando legacy...")
            self._run_legacy_cli(paths, analyze_only, **kwargs)
    
    def _run_legacy_cli(self, paths: Optional[List[str]], analyze_only: bool, **kwargs):
        """Ejecutar CLI legacy como fallback."""
        print("‚ö†Ô∏è  Usando CLI legacy...")
        
        # Importar y usar el CLI legacy
        import subprocess
        cmd = [sys.executable, "enriquecer_mp3_cli.py"]
        
        if paths:
            cmd.extend(["--directory", paths[0]])
        
        if kwargs.get('no_spotify'):
            cmd.append("--no-spotify")
        
        subprocess.run(cmd)
    
    def _run_batch_mode(self, directory: str, **kwargs):
        """Ejecutar modo batch especializado."""
        try:
            logger.info(f"üîÑ Iniciando procesamiento batch: {directory}")
            
            # Usar el sistema batch especializado
            from batch_process_mp3 import batch_process, display_results
            
            results = batch_process(
                directory=directory,
                dry_run=kwargs.get('dry_run', False),
                force=kwargs.get('force', False),
                max_files=kwargs.get('max_files'),
                workers=kwargs.get('workers', 4),
                debug=kwargs.get('debug', False)
            )
            
            display_results(results)
            
        except ImportError as e:
            logger.error(f"Batch mode no disponible: {e}")
            print("‚ùå Modo batch no disponible, usando CLI est√°ndar...")
            self._run_standard_cli([directory], False, **kwargs)

def create_parser() -> argparse.ArgumentParser:
    """Crear parser de argumentos unificado."""
    parser = argparse.ArgumentParser(
        description="üéµ Detector de G√©neros Musicales - Launcher Unificado",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    
    # Modo de ejecuci√≥n
    mode_group = parser.add_mutually_exclusive_group()
    mode_group.add_argument(
        '--gui', action='store_true',
        help='Forzar modo GUI (interfaz gr√°fica)'
    )
    mode_group.add_argument(
        '--cli', action='store_true',
        help='Forzar modo CLI (l√≠nea de comandos)'
    )
    mode_group.add_argument(
        '--batch', action='store_true',
        help='Modo procesamiento batch especializado'
    )
    mode_group.add_argument(
        '--analyze', action='store_true',
        help='Solo an√°lisis sin modificar archivos'
    )
    
    # Archivos y directorios
    parser.add_argument(
        'paths', nargs='*',
        help='Archivos MP3 o directorios a procesar'
    )
    
    # Configuraci√≥n general
    parser.add_argument(
        '--recursive', '-r', action='store_true',
        help='Procesar directorios recursivamente'
    )
    parser.add_argument(
        '--backup-dir',
        default="/Volumes/My Passport/Dj compilation 2025/Respados mp3",
        help='Directorio para backups'
    )
    parser.add_argument(
        '--confidence', type=float, default=0.3,
        help='Umbral m√≠nimo de confianza (0.0-1.0)'
    )
    parser.add_argument(
        '--max-genres', type=int, default=3,
        help='N√∫mero m√°ximo de g√©neros a asignar'
    )
    parser.add_argument(
        '--no-spotify', action='store_true',
        help='Deshabilitar API de Spotify'
    )
    parser.add_argument(
        '--verbose', '-v', action='store_true',
        help='Salida detallada'
    )
    
    # Opciones espec√≠ficas de batch
    parser.add_argument(
        '--dry-run', action='store_true',
        help='[BATCH] Solo simular cambios sin aplicar'
    )
    parser.add_argument(
        '--force', action='store_true',
        help='[BATCH] Forzar actualizaci√≥n aunque ya existan metadatos'
    )
    parser.add_argument(
        '--max-files', type=int,
        help='[BATCH] M√°ximo n√∫mero de archivos a procesar'
    )
    parser.add_argument(
        '--workers', type=int, default=4,
        help='[BATCH] N√∫mero de procesos paralelos'
    )
    parser.add_argument(
        '--debug', action='store_true',
        help='[BATCH] Informaci√≥n detallada de debug'
    )
    
    return parser

def main():
    """Funci√≥n principal del launcher unificado."""
    parser = create_parser()
    args = parser.parse_args()
    
    launcher = UnifiedLauncher()
    
    # Mostrar informaci√≥n del sistema
    print("üéµ DETECTOR DE G√âNEROS MUSICALES")
    print("=" * 40)
    print(f"GUI disponible: {'‚úÖ S√≠' if launcher.gui_available else '‚ùå No'}")
    
    try:
        # Determinar modo de ejecuci√≥n
        if args.gui:
            if launcher.gui_available:
                launcher.run_gui()
            else:
                print("‚ùå GUI no disponible en este entorno. Usando CLI...")
                launcher.run_cli(args.paths, False, **vars(args))
        
        elif args.cli:
            launcher.run_cli(args.paths, False, **vars(args))
        
        elif args.batch:
            if not args.paths:
                print("‚ùå Modo batch requiere especificar un directorio")
                sys.exit(1)
            launcher.run_cli(args.paths, False, batch_mode=True, **vars(args))
        
        elif args.analyze:
            if not args.paths:
                print("‚ùå Modo an√°lisis requiere especificar archivos")
                sys.exit(1)
            launcher.run_cli(args.paths, True, **vars(args))
        
        else:
            # Auto-detectar modo
            mode = launcher.auto_detect_mode()
            print(f"üîç Modo auto-detectado: {mode.upper()}")
            
            if mode == 'gui':
                launcher.run_gui()
            else:
                launcher.run_cli(args.paths, False, **vars(args))
    
    except KeyboardInterrupt:
        print("\nüõë Operaci√≥n cancelada por el usuario")
        sys.exit(0)
    except Exception as e:
        logger.error(f"Error cr√≠tico: {e}")
        print(f"‚ùå Error cr√≠tico: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main() 